#!/usr/bin/env python3
"""Define distributions to use."""
from logging import getLogger
from typing import List, Union, Iterable, Optional

from pydantic import BaseModel
import numpy as np
from pandas import DataFrame

from python_dummy_db.types import NumericType


class Distribution(BaseModel):
    """The Distribution BaseModel exists to provide the base for Distribution
       objects.

    Arguments you should consider setting:

    n: int the total individuals in the population
    amount: the amount of resource available to population n
    percentages: a list or Iterable list-like object (such as range)
    distribution_type: the type of distribution to use
    unit: Optional unit to use (defaults to None)
    n_unit: Optional unit to use for n variable
    check_sum_amounts_equal_to_amount: should the sum amounts be checked
        against the total amount

    Arguments you _may_ set, but are better left generated.

    data: DataFrame, generally generated by a method, but can be provided
    amounts: List of NumericType objects, generated via a method
    per_n: List of NumericType objects, generated via a method

    """
    n: int
    amount: Union[NumericType]
    percentages: List[float]
    use_units: bool = False
    unit: Optional[str] = None
    n_unit: Optional[str] = None
    check_sum_amounts_equal_to_amount: bool = False
    data: Optional[DataFrame] = None
    amounts: Optional[List[Union[NumericType]]] = None
    per_n: Optional[List[Union[NumericType]]] = None

    class Config:
        arbitrary_types_allowed = True

    def distribute(self, output: bool = True) -> Optional[DataFrame]:
        """Create the distribution dataframe."""
        if self.use_units is True:
            if self.unit:
                self.amounts = [f'{amount} ({self.unit})'
                                for amount in self.amounts]
            if self.n_unit:
                self.per_n = [f'{per} ({self.n_unit})' for per in self.per_n]
        if self.check_sum_amounts_equal_to_amount is True:
            self.check_amounts()
            self.amounts = self.amounts / sum(self.amounts) * self.amount
            self.check_amounts()
        data = {
            'Percentages': [f'{per * 100}%' for per in self.percentages],
            'Amount': self.amounts,
            'Amount per Individual in Percentage': self.per_n,
        }
        if self.use_units is True:
            # code to rename keys of the data to reflect units
            pass
        self.data = DataFrame(data)
        if output is True:
            return self.data
        return None

    def check_amounts(self, return_value: bool = False) -> Optional[bool]:
        """Check that the sum of amounts is equal to the amount."""
        sum_amounts = sum(self.amounts)
        std = np.std(self.amounts)
        std_min = self.amount - std
        std_max = self.amount + std
        if sum_amounts <= std_max and sum_amounts >= std_min:
            if return_value is True:
                return True
        else:
            log = getLogger(__name__)
            log.warning(
                f'{sum_amounts=} is not within range: {std_min}-{std_max}')
        return None

    def equal(self, distribute: bool = True) -> Optional[DataFrame]:
        """Create a normal distribution of results.
        Args:
            distribute: bool should we call self.distribute?
        """
        self.amounts = [self.amount * p for p in self.percentages]
        self.per_n = [self.n * p / amount
                      for p, amount in zip(self.percentages, self.amounts)]
        if distribute is True:
            return self.distribute()
        return None

    def left_skewed(self, distribute: bool = True):
        """Create a left-skewed distribution of results.
        Args:
            distribute: bool should we call self.distribute?
        """
        self.amounts = [self.n * (1 - 0.1 * i)
                        for i in range(len(self.percentages))]
        self.per_n = [self.n * (1 - 0.1 * i / amount)
                      for i, amount in zip(range(len(self.percentages)),
                                           self.amounts)
                      ]
        if distribute is True:
            return self.distribute()
        return None

    def right_skewed(self, distribute: bool = True):
        """Create a right-skewed distribution of results.
        Args:
            distribute: bool should we call self.distribute?
        """
        self.amounts = [self.n * 0.1 ** i
                        for i in range(len(self.percentages))]
        self.per_n = [(self.n * 0.1 ** i) / amount
                      for i, amount in zip(range(len(self.percentages)),
                                           self.amounts)
                      ]
        if distribute is True:
            return self.distribute()
        return None

    def log_normal(self, distribute: bool = True) -> Optional[DataFrame]:
        """Create a normal log distribution of results.
        Args:
            distribute: bool should we call self.distribute?
        """
        mu, sigma = np.mean(np.log(self.n)), np.std(np.log(self.n))
        self.amounts = np.exp(np.random.normal(
            mu, sigma, len(self.percentages)))
        self.per_n = [self.n * (amount / self.amount)
                      for amount in self.amounts]
        if distribute is True:
            return self.distribute()
        return None

    def exponential(self, distribute: bool = True) -> Optional[DataFrame]:
        """Create an exponential distribution of results.
        Args:
            distribute: bool should we call self.distribute?
        """
        lambda_ = 1 / np.mean(self.n)
        self.amounts = np.random.exponential(
            scale=1/lambda_,
            size=len(self.percentages),
        )
        self.per_n = [self.n * (amount / self.n) for amount in self.amounts]
        if distribute is True:
            return self.distribute()
        return None

    def pareto(
        self,
        alpha: Union[int, float] = 1.5,
        distribute: bool = True,
    ) -> Optional[DataFrame]:
        """Create a pareto distribution of results.
        Args:
            distribute: bool should we call self.distribute?
        """
        x_m = self.n / len(self.percentages)
        self.amounts = x_m * \
            (np.random.pareto(alpha, len(self.percentages)) + 1)
        self.per_n = [self.n * (amount / self.amount)
                      for amount in self.amounts]
        if distribute is True:
            return self.distribute()
        return None

    def gaussian(self, distribute: bool = True) -> Optional[DataFrame]:
        """Create a Gaussian distribution of results.
        Args:
            distribute: bool call self.distribtue()?
        """
        mu, sigma = np.mean(self.n), np.std(self.amount)
        self.amounts = np.random.normal(mu, sigma, len(self.percentages))
        self.per_n = [self.n * (amount / self.amount)
                      for amount in self.amounts]
        if distribute is True:
            return self.distribtue()
        return None

    def binomial(
        self,
        trials: int = 100,
        prob: NumericType = 0.1,
        distribute: bool = True,
    ) -> Optional[DataFrame]:
        """Create a binomial distribution of results.
        Args:
            distribute: bool call self.distribtue()?
        """
        self.amounts = \
            np.random.binomial(trials, prob, len(self.percentages)) * \
            (self.amount / trials)
        self.per_n = [self.n * (amount / self.amount)
                      for amount in self.amounts]
        if distribute is True:
            return self.distribtue()
        return None

    def poisson(self, distribute: bool = True) -> Optional[DataFrame]:
        """Create a Poisson distribution of results.
        Args:
            distribute: bool call self.distribtue()?
        """
        lambda_ = self.amount / self.n
        self.amounts = np.random.poisson(lambda_, len(self.percentages))
        self.per_n = [self.n * (amount / self.amount)
                      for amount in self.amounts]
        if distribute is True:
            return self.distribute()
        return None

    def weibull(
        self,
        alpha: NumericType = 1.5,
        beta: NumericType = 2,
        distribute: bool = True,
    ) -> Optional[DataFrame]:
        """Create a Weibull distribution of results.
        Args:
            distribute: bool call self.distribtue()?
        """
        self.amounts = np.random.weibull(alpha, len(self.percentages)) + beta
        self.per_n = [self.n * (amount / self.amount)
                      for amount in self.amounts]
        if distribute is True:
            return self.distribute()
        return None

    def uniform(
        self,
        a: NumericType = 0,
        distribute: bool = True
    ) -> Optional[DataFrame]:
        """Create a uniform distribution of results.
        Args:
            a: a value to pass to np.random.uniform's low param
            distribute: bool to distribute the results or not
        """
        self.amounts = np.random.uniform(
            a, self.amount, len(self.percentages))
        self.per_n = [self.n * (amount / self.amount)
                      for amount in self.amounts]
        if distribute is True:
            return self.distribute()
        return None

    def distribution(
        self,
        dist_type: str = "equal",
        distribute: bool = True,
        **kwargs,
    ) -> Optional[DataFrame]:
        """Create a provided distribution."""
        if dist_type.lower() == "equal":
            return self.equal(distribute=distribute)
        if dist_type.lower() == "left_skewed":
            return self.left_skewed(distribute=distribute)
        if dist_type.lower() == "right_skewed":
            return self.right_skewed(distribute=distribute)
        if dist_type.lower() == "log_normal":
            return self.log_normal(distribute=distribute)
        if dist_type.lower() == "exponential":
            return self.exponential(distribute=distribute)
        if dist_type.lower() == "pareto":
            return self.pareto(**kwargs, distribute=distribute)
        if dist_type.lower() == "gaussian":
            return self.gaussian(**kwargs, distribute=distribute)
        if dist_type.lower() == "binomial":
            return self.binomial(**kwargs, distribute=distribute)
        if dist_type.lower() == "poisson":
            return self.poisson(**kwargs, distribute=distribute)
        if dist_type.lower() == "uniform":
            return self.uniform(**kwargs, distribute=distribute)
        raise ValueError(f'"{dist_type}" not an implemented distribution')
