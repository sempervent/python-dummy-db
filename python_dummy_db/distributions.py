#!/usr/bin/env python3
"""Define distributions to use."""
from typing import List, Union, Iterable, Optional

from pydantic import BaseModel
import numpy as np
from pandas import DataFrame

from python_dummy_db.types import NumericType


class Distribution(BaseModel):
    """The Distribution BaseModel exists to provide the base for Distribution
       objects.

    Arguments you should consider setting:

    n: int representing the number of items to distribute
    amount: the
    percentages: a list or Iterable list-like object (such as range)
    distribution_type: the type of distribution to use
    unit: Optional unit to use (defaults to None)
    n_unit: Optional unit to use for n variable

    Arguments you _may_ set, but are better left generated.
    data: DataFrame, generally generated by a method, but can be provided
    amounts: List of NumericType objects, generated via a method
    per_n: List of NumericType objects, generated via a method

    """
    n: int
    amount: NumericType
    percentages: Union[List[Union[NumericType]], Iterable]
    distribution_type: str  # TODO - add check that this is a valid method
    unit: Optional[str] = None
    n_unit: Optional[str] = None
    data: Optional[DataFrame] = None
    amounts: Optional[List[Union[NumericType]]] = None
    per_n: Optional[List[Union[NumericType]]] = None

    def distribute(self, output: bool = True) -> Optional[DataFrame]:
        """Create the distribution dataframe."""
        if self.unit:
            self.amounts = [f'{amount} ({self.unit})'
                            for amount in self.amounts]
        if self.n_unit:
            self.per_n = [f'{per} ({self.n_unit})' for per in self.per_n]
        data = {
            'Percentages': [f'{per * 100}%' for per in self.percentages],
            'Amount': self.amounts,
            'Amount per Individual in Percentage': self.per_n,
        }
        self.data = DataFrame(data)
        if output is True:
            return self.data
        return None

    def equal(self, distribute: bool = True) -> Optional[DataFrame]:
        """Create a normal distribution of results.
        Args:
            distribute: bool should we call self.distribute?
        """
        self.amounts = [self.amount * p for p in self.percentages]
        self.per_n = [self.n * p / amount
                      for p, amount in zip(self.percentages, self.amounts)]
        if distribute is True:
            return self.distribute()
        return None

    def left_skewed(self, distribute: bool = True):
        """Create a left-skewed distribution of results.
        Args:
            distribute: bool should we call self.distribute?
        """
        self.amounts = [self.n * (1 - 0.1 * i)
                        for i in range(len(self.percentages))]
        self.per_n = [self.n * (1 - 0.1 * i / amount)
                      for i, amount in zip(range(len(self.percentages)),
                                           self.amounts)
                      ]
        if distribute is True:
            return self.distribute()
        return None

    def right_skewed(self, distribute: bool = True):
        """Create a right-skewed distribution of results.
        Args:
            distribute: bool should we call self.distribute?
        """
        self.amounts = [self.n * 0.1 ** i
                        for i in range(len(self.percentages))]
        self.per_n = [(self.n * 0.1 ** i) / amount
                      for i, amount in zip(range(len(self.percentages)),
                                           self.amounts)
                      ]
        if distribute is True:
            return self.distribute()
        return None

    def log_normal(self, distribute: bool = True):
        """Create a normal log distribution of results.
        Args:
            distribute: bool should we call self.distribute?
        """
        mu, sigma = np.mean(np.log(self.n)), np.std(np.log(self.n))
        self.amounts = np.exp(np.random.normal(
            mu, sigma, len(self.percentages)))
