#!/usr/bin/env python3
"""Define distributions to use."""
from logging import getLogger
from typing import List, Union, Optional

from pydantic import BaseModel
import numpy as np
from pandas import DataFrame

from python_dummy_db.types import NumericType
from python_dummy_db.methods.distributions import DISTRIBUTION_SWITCH


class Distribution(BaseModel):
    """The Distribution object can distribute a resourece to each member of
       a population according to the distribution method called.

       Args:
           population_size: int how many members are in a population
           total_resource: NumericType how much of a resource is available
           percentages: Optional list of percentages to calculate
           population_distribution: Optional list of amount of resource per
               member of the population
    """
    population_size: int
    total_resource: Union[NumericType]
    # optional arguments
    percentages: Optional[List[float]] = None
    # do not set these arguments
    population_distribution: List[float] = []

    def distribute(
        self, distribution: str, give_value: bool = False, **kwargs
    ) -> Optional[list]:
        """Distribution a distribution."""
        try:
            self.population_distribution = DISTRIBUTION_SWITCH[distribution](
                population_size=self.population_size,
                total_resource=self.total_resource,
                **kwargs,
            )
        except KeyError as exc:
            raise TypeError(
                f'Distribution requested, {distribution}, is not available.'
            ) from exc
        if give_value:
            return self.population_distribution
        return None

    def classify_population(
        self, percentages: Optional[List[float]] = None
    ) -> list:
        """Classify the population according to percentages.
        Args:
            percentages: optional list of percentages
        """
        if percentages is None and self.percentages is not None:
            percentages = self.percentages
        sorted_distribution = np.sort(self.population_distribution)[::-1]
        resource_amounts = []
        cumulative_sum = 0
        for percentage in percentages:
            wealth_amount = self.total_resource * percentage
            cumulative_sum += wealth_amount
            resource_amounts.append(cumulative_sum)
        population_classification = []
        for resource in sorted_distribution:
            for i, resource_amount in enumerate(resource_amounts):
                if resource > resource_amount:
                    population_classification.append(i)
                    break
        return population_classification

    def mean_allocation(self) -> Union[NumericType]:
        """Return the mean allocation."""
        return sum(self.population_distribution) / self.population_size

    def standard_deviation(self) -> Union[NumericType]:
        """Return the standard deviation."""
        mean = self.mean_allocation()
        variance = sum([(x - mean) ** 2
                        for x in self.population_distribution]) \
            / self.population_size
        return variance ** 0.5

    def min_allocation(self) -> Union[NumericType]:
        """Return the minimum allocaiton."""
        return min(self.population_distribution)

    def max_allocation(self) -> Union[NumericType]:
        """Return the maximum allocation."""
        return max(self.population_distribution)

    def cumulative_distribution(self) -> Union[NumericType]:
        """Return a cumulative sum of the distribution."""
        return np.cumsum(self.population_distribution)

    def percentile_allocations(
        self,
        percentile: Union[NumericType] = 0.01,
    ) -> Union[NumericType]:
        """Return the allocaiton of a given percentile."""
        return np.percentile(self.population_distribution, percentile)

    def get_percentages(self) -> Optional[DataFrame]:
        """Get a table describing the dataset based on the percentages."""
        if self.percentages is not None and len(self.percentages) > 0:
            return None


class OldDistribution(BaseModel):
    """The Distribution BaseModel exists to provide the base for Distribution
       objects.

    Arguments you should consider setting:

    n: int the total individuals in the population
    amount: the amount of resource available to population n
    percentages: a list or Iterable list-like object (such as range)
    distribution_type: the type of distribution to use
    unit: Optional unit to use (defaults to None)
    n_unit: Optional unit to use for n variable
    check_sum_amounts_equal_to_amount: should the sum amounts be checked
        against the total amount

    Arguments you _may_ set, but are better left generated.

    data: DataFrame, generally generated by a method, but can be provided
    amounts: List of NumericType objects, generated via a method
    per_n: List of NumericType objects, generated via a method

    """
    n: int
    amount: Union[NumericType]
    percentages: List[float]
    use_units: bool = False
    unit: Optional[str] = None
    n_unit: Optional[str] = None
    check_sum_amounts_equal_to_amount: bool = False
    data: Optional[DataFrame] = None
    amounts: Optional[List[Union[NumericType]]] = None
    per_n: Optional[List[Union[NumericType]]] = None

    class Config:
        arbitrary_types_allowed = True

    def distribute(self, output: bool = True) -> Optional[DataFrame]:
        """Create the distribution dataframe."""
        if self.use_units is True:
            if self.unit:
                self.amounts = [f'{amount} ({self.unit})'
                                for amount in self.amounts]
            if self.n_unit:
                self.per_n = [f'{per} ({self.n_unit})' for per in self.per_n]
        if self.check_sum_amounts_equal_to_amount is True:
            self.check_amounts()
            self.amounts = self.amounts / sum(self.amounts) * self.amount
            self.check_amounts()
        data = {
            'Percentages': [f'{per * 100}%' for per in self.percentages],
            'Amount': self.amounts,
            'Amount per Individual in Percentage': self.per_n,
        }
        if self.use_units is True:
            # code to rename keys of the data to reflect units
            pass
        self.data = DataFrame(data)
        if output is True:
            return self.data
        return None

    def check_amounts(self, return_value: bool = False) -> Optional[bool]:
        """Check that the sum of amounts is equal to the amount."""
        sum_amounts = sum(self.amounts)
        std = np.std(self.amounts)
        std_min = self.amount - std
        std_max = self.amount + std
        if sum_amounts <= std_max and sum_amounts >= std_min:
            if return_value is True:
                return True
        else:
            log = getLogger(__name__)
            log.warning(
                f'{sum_amounts=} is not within range: {std_min}-{std_max}')
        return None

    def equal(self, distribute: bool = True) -> Optional[DataFrame]:
        """Create a normal distribution of results.
        Args:
            distribute: bool should we call self.distribute?
        """
        self.amounts = [self.amount * p for p in self.percentages]
        self.per_n = [self.n * p / amount
                      for p, amount in zip(self.percentages, self.amounts)]
        if distribute is True:
            return self.distribute()
        return None

    def left_skewed(self, distribute: bool = True):
        """Create a left-skewed distribution of results.
        Args:
            distribute: bool should we call self.distribute?
        """
        self.amounts = [self.n * (1 - 0.1 * i)
                        for i in range(len(self.percentages))]
        self.per_n = [self.n * (1 - 0.1 * i / amount)
                      for i, amount in zip(range(len(self.percentages)),
                                           self.amounts)
                      ]
        if distribute is True:
            return self.distribute()
        return None

    def right_skewed(self, distribute: bool = True):
        """Create a right-skewed distribution of results.
        Args:
            distribute: bool should we call self.distribute?
        """
        self.amounts = [self.n * 0.1 ** i
                        for i in range(len(self.percentages))]
        self.per_n = [(self.n * 0.1 ** i) / amount
                      for i, amount in zip(range(len(self.percentages)),
                                           self.amounts)
                      ]
        if distribute is True:
            return self.distribute()
        return None

    def log_normal(self, distribute: bool = True) -> Optional[DataFrame]:
        """Create a normal log distribution of results.
        Args:
            distribute: bool should we call self.distribute?
        """
        mu, sigma = np.mean(np.log(self.n)), np.std(np.log(self.n))
        self.amounts = np.exp(np.random.normal(
            mu, sigma, len(self.percentages)))
        self.per_n = [self.n * (amount / self.amount)
                      for amount in self.amounts]
        if distribute is True:
            return self.distribute()
        return None

    def exponential(self, distribute: bool = True) -> Optional[DataFrame]:
        """Create an exponential distribution of results.
        Args:
            distribute: bool should we call self.distribute?
        """
        lambda_ = 1 / np.mean(self.n)
        self.amounts = np.random.exponential(
            scale=1/lambda_,
            size=len(self.percentages),
        )
        self.per_n = [self.n * (amount / self.n) for amount in self.amounts]
        if distribute is True:
            return self.distribute()
        return None

    def pareto(
        self,
        alpha: Union[int, float] = 1.5,
        distribute: bool = True,
    ) -> Optional[DataFrame]:
        """Create a pareto distribution of results.
        Args:
            distribute: bool should we call self.distribute?
        """
        x_m = self.n / len(self.percentages)
        self.amounts = x_m * \
            (np.random.pareto(alpha, len(self.percentages)) + 1)
        self.per_n = [self.n * (amount / self.amount)
                      for amount in self.amounts]
        if distribute is True:
            return self.distribute()
        return None

    def gaussian(self, distribute: bool = True) -> Optional[DataFrame]:
        """Create a Gaussian distribution of results.
        Args:
            distribute: bool call self.distribtue()?
        """
        mu, sigma = np.mean(self.n), np.std(self.amount)
        self.amounts = np.random.normal(mu, sigma, len(self.percentages))
        self.per_n = [self.n * (amount / self.amount)
                      for amount in self.amounts]
        if distribute is True:
            return self.distribtue()
        return None

    def binomial(
        self,
        trials: int = 100,
        prob: NumericType = 0.1,
        distribute: bool = True,
    ) -> Optional[DataFrame]:
        """Create a binomial distribution of results.
        Args:
            distribute: bool call self.distribtue()?
        """
        self.amounts = \
            np.random.binomial(trials, prob, len(self.percentages)) * \
            (self.amount / trials)
        self.per_n = [self.n * (amount / self.amount)
                      for amount in self.amounts]
        if distribute is True:
            return self.distribtue()
        return None

    def poisson(self, distribute: bool = True) -> Optional[DataFrame]:
        """Create a Poisson distribution of results.
        Args:
            distribute: bool call self.distribtue()?
        """
        lambda_ = self.amount / self.n
        self.amounts = np.random.poisson(lambda_, len(self.percentages))
        self.per_n = [self.n * (amount / self.amount)
                      for amount in self.amounts]
        if distribute is True:
            return self.distribute()
        return None

    def weibull(
        self,
        alpha: NumericType = 1.5,
        beta: NumericType = 2,
        distribute: bool = True,
    ) -> Optional[DataFrame]:
        """Create a Weibull distribution of results.
        Args:
            distribute: bool call self.distribtue()?
        """
        self.amounts = np.random.weibull(alpha, len(self.percentages)) + beta
        self.per_n = [self.n * (amount / self.amount)
                      for amount in self.amounts]
        if distribute is True:
            return self.distribute()
        return None

    def uniform(
        self,
        a: NumericType = 0,
        distribute: bool = True
    ) -> Optional[DataFrame]:
        """Create a uniform distribution of results.
        Args:
            a: a value to pass to np.random.uniform's low param
            distribute: bool to distribute the results or not
        """
        self.amounts = np.random.uniform(
            a, self.amount, len(self.percentages))
        self.per_n = [self.n * (amount / self.amount)
                      for amount in self.amounts]
        if distribute is True:
            return self.distribute()
        return None

    def distribution(
        self,
        dist_type: str = "equal",
        distribute: bool = True,
        **kwargs,
    ) -> Optional[DataFrame]:
        """Create a provided distribution."""
        if dist_type.lower() == "equal":
            return self.equal(distribute=distribute)
        if dist_type.lower() == "left_skewed":
            return self.left_skewed(distribute=distribute)
        if dist_type.lower() == "right_skewed":
            return self.right_skewed(distribute=distribute)
        if dist_type.lower() == "log_normal":
            return self.log_normal(distribute=distribute)
        if dist_type.lower() == "exponential":
            return self.exponential(distribute=distribute)
        if dist_type.lower() == "pareto":
            return self.pareto(**kwargs, distribute=distribute)
        if dist_type.lower() == "gaussian":
            return self.gaussian(**kwargs, distribute=distribute)
        if dist_type.lower() == "binomial":
            return self.binomial(**kwargs, distribute=distribute)
        if dist_type.lower() == "poisson":
            return self.poisson(**kwargs, distribute=distribute)
        if dist_type.lower() == "uniform":
            return self.uniform(**kwargs, distribute=distribute)
        raise ValueError(f'"{dist_type}" not an implemented distribution')
